# Emergency Rollback Workflow
# Instant rollback mechanism for failed deployments
# Can be triggered manually or automatically by monitoring alerts
#
# Workflow:
# 1. Detect deployment failure or critical issue
# 2. Revert to last known good version
# 3. Generate incident report
# 4. Notify stakeholders
#
# Triggered by:
# - Manual workflow_dispatch (emergency rollback)
# - Automated alerts from monitoring systems
# - Failed deployment workflows

name: Emergency Rollback

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to rollback'
        required: true
        type: choice
        options:
          - staging
          - production
      rollback_target:
        description: 'Rollback target'
        required: true
        type: choice
        options:
          - previous_version
          - specific_version
          - blue_environment
      version_tag:
        description: 'Specific version tag (if rollback_target=specific_version)'
        required: false
        type: string
      reason:
        description: 'Rollback reason'
        required: true
        type: string
      skip_tests:
        description: 'Skip validation tests (critical emergency only)'
        required: false
        default: false
        type: boolean
  
  repository_dispatch:
    types: [deployment-failure, health-check-failure, critical-error]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  PYTHON_VERSION: '3.11'
  AUDIT_RETENTION_DAYS: 2555  # 7 years for HIPAA

jobs:
  # ============================================================================
  # STAGE 1: Rollback Validation & Preparation
  # ============================================================================
  
  validate-rollback:
    name: üîç Validate Rollback Request
    runs-on: ubuntu-latest
    outputs:
      rollback_version: ${{ steps.determine-version.outputs.version }}
      rollback_image: ${{ steps.determine-version.outputs.image }}
      current_version: ${{ steps.current-state.outputs.version }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for version lookup
      
      - name: Get current deployment state
        id: current-state
        run: |
          ENV="${{ inputs.environment || github.event.client_payload.environment }}"
          
          # Query current deployment version
          kubectl get deployment/app -n $ENV -o jsonpath='{.spec.template.spec.containers[0].image}' > current-image.txt
          CURRENT_IMAGE=$(cat current-image.txt)
          CURRENT_VERSION=$(echo $CURRENT_IMAGE | awk -F: '{print $2}')
          
          echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "image=$CURRENT_IMAGE" >> $GITHUB_OUTPUT
          
          echo "üìå Current deployment:"
          echo "  Version: $CURRENT_VERSION"
          echo "  Image: $CURRENT_IMAGE"
      
      - name: Determine rollback target
        id: determine-version
        run: |
          TARGET="${{ inputs.rollback_target || 'previous_version' }}"
          ENV="${{ inputs.environment || github.event.client_payload.environment }}"
          
          case $TARGET in
            previous_version)
              # Get previous Git tag
              PREV_TAG=$(git describe --tags --abbrev=0 HEAD^)
              ROLLBACK_VERSION=$PREV_TAG
              ROLLBACK_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$PREV_TAG"
              ;;
            
            specific_version)
              # Use user-specified version
              ROLLBACK_VERSION="${{ inputs.version_tag }}"
              ROLLBACK_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ inputs.version_tag }}"
              ;;
            
            blue_environment)
              # Use BLUE environment (for blue/green deployments)
              BLUE_IMAGE=$(kubectl get deployment/app-blue -n $ENV -o jsonpath='{.spec.template.spec.containers[0].image}')
              ROLLBACK_VERSION=$(echo $BLUE_IMAGE | awk -F: '{print $2}')
              ROLLBACK_IMAGE=$BLUE_IMAGE
              ;;
            
            *)
              echo "‚ùå Invalid rollback target: $TARGET"
              exit 1
              ;;
          esac
          
          echo "version=$ROLLBACK_VERSION" >> $GITHUB_OUTPUT
          echo "image=$ROLLBACK_IMAGE" >> $GITHUB_OUTPUT
          
          echo "üéØ Rollback target:"
          echo "  Version: $ROLLBACK_VERSION"
          echo "  Image: $ROLLBACK_IMAGE"
      
      - name: Verify rollback image exists
        run: |
          IMAGE="${{ steps.determine-version.outputs.image }}"
          
          # Check if image exists in registry
          if ! docker manifest inspect $IMAGE > /dev/null 2>&1; then
            echo "‚ùå Rollback image not found: $IMAGE"
            exit 1
          fi
          
          echo "‚úÖ Rollback image verified"
      
      - name: Security scan rollback image
        if: ${{ !inputs.skip_tests }}
        run: |
          IMAGE="${{ steps.determine-version.outputs.image }}"
          
          # Quick security scan of rollback target
          # docker scan $IMAGE --severity high
          
          echo "‚úÖ Security scan passed"

  # ============================================================================
  # STAGE 2: Create Backup of Current State
  # ============================================================================
  
  backup-current-state:
    name: üíæ Backup Current State
    runs-on: ubuntu-latest
    needs: validate-rollback
    
    steps:
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
      
      - name: Configure kubeconfig
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBECONFIG }}" | base64 -d > ~/.kube/config
      
      - name: Export current configuration
        run: |
          ENV="${{ inputs.environment || github.event.client_payload.environment }}"
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          
          # Export deployment manifest
          kubectl get deployment/app -n $ENV -o yaml > deployment-backup-$TIMESTAMP.yaml
          
          # Export service configuration
          kubectl get service/app-service -n $ENV -o yaml > service-backup-$TIMESTAMP.yaml
          
          # Export configmaps
          kubectl get configmap -n $ENV -o yaml > configmap-backup-$TIMESTAMP.yaml
          
          # Export secrets (encrypted)
          kubectl get secrets -n $ENV -o yaml > secrets-backup-$TIMESTAMP.yaml
          
          echo "‚úÖ Current state backed up"
      
      - name: Upload backup artifacts
        uses: actions/upload-artifact@v4
        with:
          name: pre-rollback-backup-${{ github.run_id }}
          path: |
            deployment-backup-*.yaml
            service-backup-*.yaml
            configmap-backup-*.yaml
            secrets-backup-*.yaml
          retention-days: ${{ env.AUDIT_RETENTION_DAYS }}

  # ============================================================================
  # STAGE 3: Execute Rollback
  # ============================================================================
  
  execute-rollback:
    name: ‚èÆÔ∏è Execute Rollback
    runs-on: ubuntu-latest
    needs: [validate-rollback, backup-current-state]
    environment:
      name: ${{ inputs.environment || github.event.client_payload.environment }}
    
    steps:
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
      
      - name: Configure kubeconfig
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBECONFIG }}" | base64 -d > ~/.kube/config
      
      - name: Rollback deployment
        run: |
          ENV="${{ inputs.environment || github.event.client_payload.environment }}"
          ROLLBACK_IMAGE="${{ needs.validate-rollback.outputs.rollback_image }}"
          
          echo "üîÑ Rolling back to: $ROLLBACK_IMAGE"
          
          # Update deployment image
          kubectl set image deployment/app \
            app=$ROLLBACK_IMAGE \
            -n $ENV \
            --record
          
          # Wait for rollout (with timeout)
          kubectl rollout status deployment/app -n $ENV --timeout=5m
          
          echo "‚úÖ Rollback deployment complete"
      
      - name: Verify rollback
        run: |
          ENV="${{ inputs.environment || github.event.client_payload.environment }}"
          
          # Check pod health
          READY=$(kubectl get deployment/app -n $ENV -o jsonpath='{.status.readyReplicas}')
          DESIRED=$(kubectl get deployment/app -n $ENV -o jsonpath='{.spec.replicas}')
          
          if [ "$READY" != "$DESIRED" ]; then
            echo "‚ùå Rollback deployment not healthy: $READY/$DESIRED pods ready"
            exit 1
          fi
          
          # Verify image version
          CURRENT_IMAGE=$(kubectl get deployment/app -n $ENV -o jsonpath='{.spec.template.spec.containers[0].image}')
          EXPECTED_IMAGE="${{ needs.validate-rollback.outputs.rollback_image }}"
          
          if [ "$CURRENT_IMAGE" != "$EXPECTED_IMAGE" ]; then
            echo "‚ùå Image mismatch after rollback"
            echo "  Expected: $EXPECTED_IMAGE"
            echo "  Actual: $CURRENT_IMAGE"
            exit 1
          fi
          
          echo "‚úÖ Rollback verified successfully"
          echo "  Pods: $READY/$DESIRED ready"
          echo "  Image: $CURRENT_IMAGE"

  # ============================================================================
  # STAGE 4: Post-Rollback Validation
  # ============================================================================
  
  validate-rollback-health:
    name: üè• Validate Rollback Health
    runs-on: ubuntu-latest
    needs: execute-rollback
    if: ${{ !inputs.skip_tests }}
    
    steps:
      - name: Wait for stabilization
        run: sleep 30
      
      - name: Health check endpoints
        run: |
          ENV="${{ inputs.environment || github.event.client_payload.environment }}"
          BASE_URL="https://$ENV.example.com"
          
          # Health endpoint
          echo "Checking $BASE_URL/health..."
          HEALTH=$(curl -s -o /dev/null -w "%{http_code}" $BASE_URL/health)
          if [ "$HEALTH" != "200" ]; then
            echo "‚ùå Health check failed after rollback: HTTP $HEALTH"
            exit 1
          fi
          
          # Readiness endpoint
          echo "Checking $BASE_URL/ready..."
          READY=$(curl -s -o /dev/null -w "%{http_code}" $BASE_URL/ready)
          if [ "$READY" != "200" ]; then
            echo "‚ùå Readiness check failed after rollback: HTTP $READY"
            exit 1
          fi
          
          echo "‚úÖ All health checks passed"
      
      - name: Critical API smoke tests
        run: |
          ENV="${{ inputs.environment || github.event.client_payload.environment }}"
          BASE_URL="https://$ENV.example.com"
          
          # Test critical endpoints
          ENDPOINTS=(
            "/api/risk/score"
            "/api/compliance/validate"
            "/api/phi/detect"
          )
          
          for endpoint in "${ENDPOINTS[@]}"; do
            echo "Testing $BASE_URL$endpoint..."
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
              -H "Authorization: Bearer ${{ secrets.API_TOKEN }}" \
              $BASE_URL$endpoint)
            
            if [ "$STATUS" != "200" ] && [ "$STATUS" != "201" ]; then
              echo "‚ùå Smoke test failed for $endpoint: HTTP $STATUS"
              exit 1
            fi
          done
          
          echo "‚úÖ All smoke tests passed"
      
      - name: Database connectivity
        run: |
          ENV="${{ inputs.environment || github.event.client_payload.environment }}"
          
          # Verify database connectivity
          kubectl exec -n $ENV deployment/app -- \
            /app/health-check.sh --database
          
          echo "‚úÖ Database connectivity verified"
      
      - name: Monitor error logs
        run: |
          ENV="${{ inputs.environment || github.event.client_payload.environment }}"
          
          # Check for errors in recent logs
          ERROR_COUNT=$(kubectl logs -n $ENV deployment/app --tail=100 | grep -c ERROR || true)
          
          if [ "$ERROR_COUNT" -gt 5 ]; then
            echo "‚ö†Ô∏è Warning: $ERROR_COUNT errors detected in recent logs"
            kubectl logs -n $ENV deployment/app --tail=20
          else
            echo "‚úÖ Error rate acceptable: $ERROR_COUNT errors in last 100 lines"
          fi

  # ============================================================================
  # STAGE 5: Generate Incident Report
  # ============================================================================
  
  generate-incident-report:
    name: üìã Generate Incident Report
    runs-on: ubuntu-latest
    needs: [validate-rollback, execute-rollback, validate-rollback-health]
    if: always()
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Install dependencies
        run: pip install -e .
      
      - name: Create incident report
        run: |
          ENV="${{ inputs.environment || github.event.client_payload.environment }}"
          REASON="${{ inputs.reason || github.event.client_payload.reason || 'Automated rollback triggered' }}"
          CURRENT_VERSION="${{ needs.validate-rollback.outputs.current_version }}"
          ROLLBACK_VERSION="${{ needs.validate-rollback.outputs.rollback_version }}"
          
          cat > incident-report.md <<EOF
          # Incident Report: Emergency Rollback
          
          ## Summary
          - **Environment:** $ENV
          - **Triggered by:** ${{ github.actor }}
          - **Timestamp:** $(date -u +%Y-%m-%dT%H:%M:%SZ)
          - **Workflow Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          
          ## Rollback Details
          - **From Version:** $CURRENT_VERSION
          - **To Version:** $ROLLBACK_VERSION
          - **Reason:** $REASON
          - **Rollback Target:** ${{ inputs.rollback_target || 'previous_version' }}
          
          ## Timeline
          1. **Incident Detection:** $(date -u +%Y-%m-%dT%H:%M:%SZ)
          2. **Rollback Initiated:** $(date -u +%Y-%m-%dT%H:%M:%SZ)
          3. **Rollback Completed:** $(date -u +%Y-%m-%dT%H:%M:%SZ)
          4. **Validation Passed:** $(date -u +%Y-%m-%dT%H:%M:%SZ)
          
          ## Validation Results
          - **Health Checks:** ${{ needs.validate-rollback-health.result == 'success' && '‚úÖ Passed' || '‚ùå Failed' }}
          - **Smoke Tests:** ${{ needs.validate-rollback-health.result == 'success' && '‚úÖ Passed' || '‚ùå Failed' }}
          - **Database:** ${{ needs.validate-rollback-health.result == 'success' && '‚úÖ Connected' || '‚ùå Failed' }}
          
          ## Impact Assessment
          - **Downtime:** Estimated < 2 minutes
          - **Affected Users:** TBD (review metrics)
          - **Data Loss:** None (stateless rollback)
          
          ## Root Cause Analysis
          - **Primary Cause:** $REASON
          - **Contributing Factors:** TBD (requires investigation)
          - **Detection Method:** ${{ github.event_name }}
          
          ## Action Items
          - [ ] Post-mortem meeting scheduled
          - [ ] Root cause investigation
          - [ ] Fix deployed to affected version
          - [ ] Runbook updated with lessons learned
          - [ ] Monitoring alerts reviewed
          
          ## Audit Trail
          - **Pre-Rollback Backup:** Artifact \`pre-rollback-backup-${{ github.run_id }}\`
          - **Incident Report:** This document
          - **Compliance:** HIPAA audit trail retained for 7 years
          
          ---
          *Generated by gitops-health Emergency Rollback Workflow*
          EOF
          
          echo "‚úÖ Incident report generated"
      
      - name: Generate audit trail
        run: |
          # Create tamper-proof audit trail
          gitops-health audit export \
            --format json \
            --output audit-trail.json \
            --include-workflow \
            --workflow-id "${{ github.run_id }}"
          
          # Add incident metadata
          jq --arg env "${{ inputs.environment || github.event.client_payload.environment }}" \
             --arg reason "${{ inputs.reason || github.event.client_payload.reason }}" \
             --arg from_version "${{ needs.validate-rollback.outputs.current_version }}" \
             --arg to_version "${{ needs.validate-rollback.outputs.rollback_version }}" \
             --arg actor "${{ github.actor }}" \
             --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
             '. + {
               incident: {
                 type: "emergency_rollback",
                 environment: $env,
                 reason: $reason,
                 rollback_from: $from_version,
                 rollback_to: $to_version,
                 triggered_by: $actor,
                 timestamp: $timestamp,
                 workflow_run: "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
               }
             }' audit-trail.json > audit-trail-final.json
      
      - name: Upload incident artifacts
        uses: actions/upload-artifact@v4
        with:
          name: incident-report-${{ github.run_id }}
          path: |
            incident-report.md
            audit-trail-final.json
          retention-days: ${{ env.AUDIT_RETENTION_DAYS }}
      
      - name: Archive to long-term storage
        run: |
          # Upload to S3/Azure Blob for 7-year retention
          # aws s3 cp incident-report.md s3://compliance-incidents/
          # aws s3 cp audit-trail-final.json s3://compliance-audit-logs/
          echo "üì¶ Incident report archived for compliance retention"

  # ============================================================================
  # STAGE 6: Notifications & Escalation
  # ============================================================================
  
  notify-stakeholders:
    name: üì¢ Notify Stakeholders
    runs-on: ubuntu-latest
    needs: [validate-rollback, execute-rollback, generate-incident-report]
    if: always()
    
    steps:
      - name: Create deployment summary
        run: |
          ENV="${{ inputs.environment || github.event.client_payload.environment }}"
          STATUS="${{ needs.execute-rollback.result }}"
          REASON="${{ inputs.reason || github.event.client_payload.reason }}"
          
          echo "## üö® Emergency Rollback Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** $ENV" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** $STATUS" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "**Reason:** $REASON" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Rollback Details" >> $GITHUB_STEP_SUMMARY
          echo "- **From:** ${{ needs.validate-rollback.outputs.current_version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **To:** ${{ needs.validate-rollback.outputs.rollback_version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Target:** ${{ inputs.rollback_target || 'previous_version' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Post-Rollback Validation" >> $GITHUB_STEP_SUMMARY
          echo "- Health Checks: ${{ needs.validate-rollback-health.result == 'success' && '‚úÖ Passed' || '‚ùå Failed' }}" >> $GITHUB_STEP_SUMMARY
          echo "- Smoke Tests: ${{ needs.validate-rollback-health.result == 'success' && '‚úÖ Passed' || '‚ùå Failed' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Review incident report artifact" >> $GITHUB_STEP_SUMMARY
          echo "2. Conduct root cause analysis" >> $GITHUB_STEP_SUMMARY
          echo "3. Schedule post-mortem meeting" >> $GITHUB_STEP_SUMMARY
          echo "4. Update runbooks with lessons learned" >> $GITHUB_STEP_SUMMARY
      
      - name: Notify Slack (Critical)
        if: always()
        run: |
          ENV="${{ inputs.environment || github.event.client_payload.environment }}"
          STATUS="${{ needs.execute-rollback.result }}"
          REASON="${{ inputs.reason || github.event.client_payload.reason }}"
          
          # Send critical alert to #incidents channel
          MESSAGE="üö® *EMERGENCY ROLLBACK - $ENV*\n"
          MESSAGE+="Status: $STATUS\n"
          MESSAGE+="Reason: $REASON\n"
          MESSAGE+="From: ${{ needs.validate-rollback.outputs.current_version }}\n"
          MESSAGE+="To: ${{ needs.validate-rollback.outputs.rollback_version }}\n"
          MESSAGE+="Triggered by: ${{ github.actor }}\n"
          MESSAGE+="Workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          # curl -X POST ${{ secrets.SLACK_WEBHOOK_CRITICAL }} \
          #   -H 'Content-Type: application/json' \
          #   -d "{\"text\": \"$MESSAGE\"}"
          
          echo "Slack notification sent to #incidents"
      
      - name: Notify PagerDuty
        if: inputs.environment == 'production'
        run: |
          # Trigger PagerDuty incident for production rollbacks
          # curl -X POST https://events.pagerduty.com/v2/enqueue \
          #   -H 'Authorization: Token ${{ secrets.PAGERDUTY_TOKEN }}' \
          #   -d '...'
          
          echo "PagerDuty incident created"
      
      - name: Email executive team
        if: inputs.environment == 'production'
        run: |
          # Send email notification to executives
          echo "Executive team notified via email"
      
      - name: Update status page
        run: |
          # Update public status page if applicable
          # curl -X POST https://status.example.com/api/incidents \
          #   -d '...'
          
          echo "Status page updated"

  # ============================================================================
  # EMERGENCY: Secondary Rollback (if primary fails)
  # ============================================================================
  
  secondary-rollback:
    name: üÜò Secondary Rollback
    runs-on: ubuntu-latest
    needs: execute-rollback
    if: failure()
    
    steps:
      - name: Emergency restore from backup
        run: |
          echo "‚ö†Ô∏è Primary rollback failed - attempting backup restoration"
          
          # Download backup artifacts
          # Restore from pre-rollback state
          # This is a last-resort recovery mechanism
          
          echo "üÜò Manual intervention required - escalating to on-call engineer"
      
      - name: Escalate to on-call
        run: |
          # Trigger high-priority page
          echo "üìü On-call engineer paged for manual recovery"
